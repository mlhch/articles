<h1>W3C - HTML5 Manifest</h1>

<p>2014-02-23 18:38 Sunday</p>

<p><a href="http://www.w3.org/TR/appmanifest/" target="_blank">http://www.w3.org/TR/appmanifest/</a></p>

<h2>使用应用缓存</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache" target="_blank">https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache</a></p>

<h3>开启应用缓存</h3>

<p>若想为应用开启应用缓存，你需要在应用页面中的&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/HTML/Element/html">&lt;html&gt;</a>&nbsp;元素上增加&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html#attr-manifest">manifest</a>&nbsp;特性，请看下面的例子：</p>

<pre>
<span class="marker">&lt;html manifest=&quot;example.appcache&quot;&gt; </span>
  ...
&lt;/html&gt;
</pre>

<p>manifest 特性与&nbsp;缓存清单(cache manifest)&nbsp;文件关联，这个文件包含了浏览器需要为你的应用缓存的资源(文件)列表。</p>

<p>你应当在每一个意图缓存的页面上添加 manifest 特性。浏览器不会缓存不带有manifest 特性的页面，除非这个页面已经被写在清单文件内的列表里了。你没有必要添加所有你意图缓存的页面的清单文件，浏览器会将用户访问过的并带有 manifest 特性的所有页面添加进应用缓存中。</p>

<p>有些浏览器，比如说firefox，当用户首次加载一个需要使用应用缓存的应用时，会显示一个提示栏。提示信息如下：</p>

<p>该站点 (www.example.com) 请求在你的电脑上存储数据以供离线使用。[允许] [对此站点永不允许] [暂时不允许]</p>

<h2>存储位置与清除离线缓存</h2>

<p>在 Chrome 中，你可以在设置中选择 「清除浏览器数据...」 或访问&nbsp;<span class="marker">chrome://appcache-internals/</span>&nbsp;来清除缓存。Safari 在设置中有一个类似的&quot;清空缓存&quot; 选项，但是需要重启浏览器后才能生效。</p>

<p>在 Firefox 中，离线缓存数据与 Firefox 配置文件是分开存储的&mdash;紧挨着硬盘缓存：</p>

<ul>
	<li>Windows Vista/7:&nbsp;C:\Users\&lt;username&gt;\AppData\Local\Mozilla\Firefox\Profiles\&lt;salt&gt;.&lt;profile name&gt;\OfflineCache</li>
	<li>Mac/Linux:&nbsp;/Users/&lt;username&gt;/Library/Caches/Firefox/Profiles/&lt;salt&gt;.&lt;profile name&gt;/OfflineCache</li>
</ul>

<p>在 Firefox 中可以通过访问&nbsp;about:cache&nbsp;页面(在「离线缓存设置」标题下)来检查离线缓存的当前状况。 若想单独清除每个网站的离线缓存，可以使用 工具 -&gt; 选项 -&gt; 高级 -&gt; 网络 -&gt; 离线数据中的「删除」按钮。</p>

<p>在 Firefox 11 之前，无论是 工具 -&gt; 清除近期历史 还是 工具 -&gt; 选项 -&gt; 高级 -&gt; 网络 -&gt; 离线数据 -&gt; 立即清除 都无法清除离线缓存。这个问题已经被修复。(点击 &ldquo;立即清除&rdquo; 只是将缓存文件清除掉，并没将缓存清单删除，所以下次载入页面是更新缓存，而非创建缓存，意味着cached和updateready事件触发机制不同，如果想要清除掉缓存清单，只能选中域，然后点击移除)</p>

<h2>缓存清单文件</h2>

<h3>引用一个缓存清单文件</h3>

<p>web 应用中的&nbsp;manifest&nbsp;特性可以指定为缓存清单文件的相对路径或一个绝对 URL(绝对 URL 必须与应用同源)。缓存清单文件可以使用任意扩展名，但传输它的 MIME 类型必须为&nbsp;text/cache-manifest。</p>

<p>注意：在 Apache 服务器上，若要设置适用于清单(.appcache)文件的 MIME 类型，可以向根目录或应用的同级目录下的一个 .htaccess 文件中增加&nbsp;AddType text/cache-manifest .appcache&nbsp;。</p>

<h3>缓存清单文件中的记录</h3>

<p>缓存清单文件是一个纯文本文件，它列出了所有浏览器应该缓存起来的资源，以便能够离线访问。资源使用 URI 来标识。在缓存清单文件中列出的所有记录必须拥有相同的协议、主机名与端口号。</p>

<h3>示例 1：一个简单的缓存清单文件</h3>

<p>下面是一个简单的缓存清单文件，example.appcache，适用于一个虚拟的网站&nbsp;www.example.com。</p>

<pre>
<span class="marker">CACHE MANIFEST
# v1 - 2011-08-13</span>
# This is a comment.
http://www.example.com/index.html
http://www.example.com/header.png
http://www.example.com/blah/blah
</pre>

<p>一个缓存清单文件可以包含三段内容 (CACHE，&nbsp;NETWORK，&nbsp;和&nbsp;FALLBACK，&nbsp;下面详细讨论)。 在上面的例子中，没有段落标题，因此所有数据行都认为是属于显式 (CACHE) 段落，这意味着浏览器应该在应用缓存中缓存所有列出的资源。资源可以使用绝对或者相对 URL 来指定(例如&nbsp;index.html)。</p>

<p>上面例子中的注释 「v1」很有必要存在。只有当清单文件发生变化时，浏览器才会去更新应用缓存。如果你要更改缓存资源(比如说，你使用了一张新的&nbsp;header.png&nbsp;图片)，你必须同时修改清单文件中的内容，以便让浏览器知道它们需要更新缓存。你可以对清单文件做任何改动，但大家都认同的最佳实践则是修正版本号。</p>

<p>重要：不要在清单文件中指定清单文件本身，否则将无法让浏览器得知清单文件有新版本出现。</p>

<h3>缓存清单文件中的段落：&nbsp;CACHE，&nbsp;NETWORK，与&nbsp;FALLBACK</h3>

<p>清单文件可以分为三段：&nbsp;CACHE，&nbsp;NETWORK，与&nbsp;FALLBACK.</p>

<p>CACHE:</p>

<p>这是缓存文件中记录所属的默认段落。在&nbsp;CACHE:&nbsp;段落标题后(或直接跟在&nbsp;CACHE MANIFEST&nbsp;行后)列出的文件会在它们第一次下载完毕后缓存起来。</p>

<p>NETWORK:</p>

<p>在&nbsp;NETWORK:&nbsp;段落标题下列出的文件是需要与服务器连接的白名单资源。所有类似资源的请求都会绕过缓存，即使用户处于离线状态。可以使用通配符。</p>

<p>FALLBACK:</p>

<p>FALLBACK:&nbsp;段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI&mdash;第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。</p>

<p>CACHE，&nbsp;NETWORK，&nbsp;和&nbsp;FALLBACK 段落可以以任意顺序出现在缓存清单文件中，并且每个段落可以在同一清单文件中出现多次。</p>

<h3>示例 2： 一个复杂且完整的缓存清单文件</h3>

<p>下面是一个更加完整的缓存清单文件，适用于一个虚拟的网站&nbsp;www.example.com：</p>

<pre>
CACHE MANIFEST
# v1 2011-08-14
# This is another comment
index.html
cache.html
style.css
image1.png

# Use from network if available
NETWORK:
network.html

# Fallback content
FALLBACK:
/ fallback.html
</pre>

<p>该例子使用了&nbsp;NETWORK&nbsp;与&nbsp;FALLBACK&nbsp;段落，指明了&nbsp;network.html&nbsp;页面必须始终从网络获取，fallback.html&nbsp;页面应该作为后备资源来提供(例如，当无法与服务器建立连接时)。</p>

<h3>缓存清单文件的结构</h3>

<p>缓存清单文件必须以&nbsp;text/cache-manifest&nbsp;MIME 类型来传输。所有通过 MIME 类型传输的文件必须符合本节中定义的适用于应用缓存清单的语法。</p>

<p>缓存清单是 UTF-8 格式的文本文件，有可能包含一个 BOM 字符。新行可能使用换行符(U+000A)，回车(U+000D)，或回车加换行符来表示。</p>

<p>缓存清单文件的第一行必须包含字符串&nbsp;CACHE MANIFEST&nbsp;(两个单词间使用一个&nbsp;U+0020&nbsp;空白)，紧接着是零或多个空白或制表符。本行的其他文本会被忽略。</p>

<p>缓存清单文件的余下内容必须包含零或多个下面的行：</p>

<p>空行</p>

<p>你可以使用包含零或多个空白与制表符的空行。</p>

<p>注释</p>

<p>注释包括零或多个制表符或空白字符，紧接着是一个&nbsp;#&nbsp;字符，再然后是零或多个注释文本字符。注释只能在所在行起作用，不能追加到其他行上。这意味着你无法使用片段标识符。</p>

<p>段落标题</p>

<p>段落标题指定了缓存文件即将操作的段落。有三个可选的标题：</p>

<blockquote>
<table>
	<tbody>
		<tr>
			<th>段落标题</th>
			<th>解释</th>
		</tr>
		<tr>
			<td>CACHE:</td>
			<td>切换到缓存清单的显式段落(默认段落)。</td>
		</tr>
		<tr>
			<td>NETWORK:</td>
			<td>切换到缓存清单的在线白名单段落。</td>
		</tr>
		<tr>
			<td>FALLBACK:</td>
			<td>切换到缓存清单的后备资源段落。</td>
		</tr>
	</tbody>
</table>
</blockquote>

<p>段落标题所在的行可以包含空白字符，段落名后的冒号 (:) 不可省略。</p>

<p>段落数据</p>

<p>不同段落的数据行格式有所不同。在默认 (CACHE:) 段落，每行都是一个合法的 &nbsp;URI 或 IRI ，与一个要缓存的资源相关联(本段落内不允许通配符)。每行的 URI 或 IRI 前后允许出现空白字符。在 Fallback 段落内，每行都是一个合法的 URI 或 IRI(与一个资源关联)，紧跟着一个后备资源，用于当无法与服务器建立连接时访问。在 Network 段落内，每行都是一个合法的 URI 或 IRI，关联一个需要通过网络获取的资源(本段落内可以使用通配符 *)。</p>

<p>注意：相对 URI 是指相对于缓存清单的 URI，而不是包含清单的文档的 URI。</p>

<p>缓存清单可以在段落内任意切换(每个段落标题可以使用多次)，而且段落允许为空。</p>

<h2>一个应用缓存中的资源</h2>

<p>一个应用缓存至少会包含一个资源，由 URI 指定。所有资源都属于下列类别之一：</p>

<p>主记录</p>

<p>这些资源被加入缓存的原因是：用户浏览的一个上下文中包含一个文档，该文档用&nbsp;manifest&nbsp;特性明确指明了它属于该缓存。</p>

<p>显式记录</p>

<p>这些是在应用缓存清单文件中显式列出的资源。</p>

<p>网络记录</p>

<p>这些是在应用缓存清单文件中作为网络记录列出的资源。</p>

<p>后备记录</p>

<p>这些是在应用缓存清单文件中作为后备记录列出的资源。</p>

<p>注意：&nbsp;资源可以被标记为多个类别，因此可以作为多重记录来分类。例如，一条记录既可以是显式记录，也可以是一条后备记录。</p>

<p>下面来详细介绍资源类别。</p>

<h3>主记录</h3>

<p>任意在&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/HTML/Element/html">&lt;html&gt;</a>&nbsp;元素上包含一个&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html#attr-manifest">manifest</a>&nbsp;特性的 HTML 文件都可以是主记录。例如，我们拥有 HTML 文件&nbsp;<a href="http://www.foo.bar/entry.html">http://www.example.com/entry.html</a>，它看起来是这样的：</p>

<pre>
&lt;html manifest=&quot;example.appcache&quot;&gt;
  &lt;h1&gt;Application Cache Example&lt;/h1&gt;
&lt;/html&gt;
</pre>

<p>如果&nbsp;entry.html&nbsp;没有在&nbsp;example.appcache&nbsp;缓存清单文件中列出来，那么访问&nbsp;entry.html&nbsp;页面会使得&nbsp;entry.html&nbsp;作为一条主记录加入到应用缓存中。</p>

<h3>显式记录</h3>

<p>显式记录就是在缓存清单文件的&nbsp;CACHE 段落显式列出的资源。</p>

<h3>网络记录</h3>

<p>缓存清单文件的&nbsp;NETWORK&nbsp;段落指定了 web 应用需要在线访问的资源。一个应用缓存中的网络记录本质上来说是一个「在线白名单」&mdash;在&nbsp;NETWORK&nbsp;段落指定的 URI 会从服务器而不是缓存加载。这使得浏览器的安全模型通过限制用户让其只访问经过验证的资源来避免潜在的安全漏洞。</p>

<p>举例来说，你可以使用网络记录来从服务器而不是缓存中加载并执行脚本或其他代码：</p>

<pre>
CACHE MANIFEST
NETWORK:
/api
</pre>

<p>上面列出的缓存清单段落能够保证对&nbsp;<a href="http://www.example.com/api/">http://www.example.com/api/</a>&nbsp;子目录中资源的请求始终通过网络加载，而不会去访问缓存。</p>

<p>注意：&nbsp;简单的从清单文件中过滤主记录(在&nbsp;html 元素中拥有&nbsp;manifest&nbsp;特性的文件)并不会产生同样的结果，因为主记录会被添加到&mdash;后续访问的获取也会从&mdash;应用缓存中。</p>

<h3>后备记录</h3>

<p>当尝试请求资源失败时会使用后备记录。例如，缓存清单文件&nbsp;<a href="http://www.example.com/example.appcache">http://www.example.com/example.appcache</a>&nbsp;包含如下内容：</p>

<pre>
CACHE MANIFEST
FALLBACK:
example/bar/ example.html
</pre>

<p>任何访问&nbsp;<a href="http://www.example.com/example/bar/">http://www.example.com/example/bar/</a>&nbsp;或它的任意子目录及内容都会使浏览器发出请求，去尝试加载请求的资源。如果尝试失败(可能是由于网络连接失败或服务器问题)，浏览器将会加载&nbsp;example.html。</p>

<h2>缓存状态</h2>

<p>每个应用缓存都有一个状态，标示着缓存的当前状况。共享同一清单 URI 的缓存拥有相同的缓存状态，可能是其中之一：</p>

<p>UNCACHED(未缓存)</p>

<p>一个特殊的值，用于表明一个应用缓存对象还没有完全初始化。</p>

<p>IDLE(空闲)</p>

<p>应用缓存此时未处于更新过程中。</p>

<p>CHECKING(检查)</p>

<p>清单已经获取完毕并检查更新。</p>

<p>DOWNLOADING(下载中)</p>

<p>下载资源并准备加入到缓存中，这是由于清单变化引起的。</p>

<p>UPDATEREADY(更新就绪)</p>

<p>一个新版本的应用缓存可以使用。有一个对应的事件&nbsp;updateready，当下载完毕一个更新，并且还未使用&nbsp;swapCache() 方法激活更新时，该事件触发，而不会是&nbsp;cached&nbsp;事件。</p>

<p>OBSOLETE(废弃)</p>

<p>应用缓存现在被废弃。</p>

<p><a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank">http://www.w3school.com.cn/html5/html_5_app_cache.asp</a></p>

<h2>注意事项</h2>

<ol>
	<li>引入 manifest方式为 : &lt;html manifest=&quot;name.appcache&quot;&gt;</li>
	<li>manifest 的加载是晚于页面其他资源的</li>
	<li>manifest的contentType应为 : text/cache-manifest</li>
	<li>建议其扩展名为 : appcache</li>
	<li>manifest 文件本质是一个要采用UTF-8编码方式编码的文本文件</li>
	<li>引入 manifest 的页面即使没有被列入缓存清单中，仍然会被用户代理缓存</li>
	<li>manifest 文件从标准角度来说,是不能直接从缓存读取的.即使像上一条说的，你明确的把manifest放入另一个清单中，至少也是服务器尝试返回304.再去读缓存.(注1)</li>
	<li>在线的情况下，用户代理每次访问页面，都会去读一次 manifest。如果发现其改变, 则重新加载全部清单中的资源(注2)</li>
	<li>对于浏览器来说，manifest 的加载是要晚于其他资源的。这就导致 check manifest 的过程是滞后的。发现 manifest 改变，所有浏览器的实现都是紧随这做静默更新资源，以保证下次 pv 应用到更新</li>
	<li>manifest 文件必须与引入它的页面同源.</li>
	<li>如果 manifest 文件是一个 https 或其他加密协议资源，则其清单中明示项(explicit section)的资源都必须和manifest同源</li>
	<li>备用项和备用名称空间，必须与当前的manifest同源</li>
	<li>备用项如果发生命中，则也会被缓存</li>
	<li>明示项和备用项优先级高于白名单</li>
	<li>白名单使用通配符&ldquo;*&rdquo;，则会进入白名单的 open 状态。这种状态下所有不在相关Cache区域出现的url都默认使用HTTP相关缓存头策略</li>
	<li>白名单使用具体的前缀匹配或更具体的URL，则都属于blocking状态。这种状态下，白名单所匹配的，非Cache区域出现的URL，与open的*匹配的结果一致,但是不在白名单中，又不在整个manifest 的资源，会block。也就是访问、加载不能</li>
	<li>manifest 中的 url，必须与 manifest 使用相同的协议</li>
	<li>一个 manifest 的明示项中可以包含另一个 manifest.(但这种设计，我认为很2.)</li>
	<li>manifest 中的 url 不应有&ldquo;#&rdquo;锚点部分出现(比如 abc.htm#1,如果出现#,则 #以及后面部分，会被丢弃.)</li>
	<li>建议使用&lt;!DOCTYPE html&gt; DTD, 因为据说,某些浏览器会因为，进入非标准模式,而无视manifest</li>
	<li>(我本人没有实测，但我个人猜测，如果有这样一款浏览器，那么它很可能就是IE10. 因为IE10进入兼容模式,很多html5草案的API都使用不能.比如performance API)</li>
	<li>被清单缓存的资源,是无视http cache 相关 头域, 或其是否是https资源的.</li>
	<li>相同备用名称空间,不能重复出现在 备用区域中.</li>
	<li>不应有相包含的备用名称空间出现在备用区域中(因为前缀匹配的原因.出现包含，显然是多余的，如果真有一个URL同时匹配两个通配符.那么就以更长的那个为准.)</li>
	<li>备用名称空间 和 白名单名称空间 都使用前缀匹配模式.即支持通配符匹配模式.(可以放心的是 //www.a.com/abc 是不匹配 //www.a.com/ab的,因为//www.a.com/ab 实际上是//www.a.com/ab/)</li>
	<li>前缀匹配对端口的匹配是宽松的.如abc.com:80/a.png 就会被 abc.com/所匹配</li>
	<li>在写相对路径的时候 不是相对 引入它的html 而是相对 manifest文件所在目录的</li>
	<li>一但manifest检测,需要更新,导致所有cache资源更新。其中manifest会再次加载一次.(所以给所有缓存资源配置合理的304机制.是十分有必要的.)</li>
	<li>一组不同的页面引入相同的manifest文件时,这组页面的即构构成一个group.并已document作为标识,来区分他们.其中任何一个的manifest或资源更新,甚至是检测都会触发其他页面的applicationCache的相应事件.</li>
	<li>applicationCache.update(), 只会立刻检测manifest文件,而不会更新相应资源.并且会遵守304相关http缓存头</li>
	<li>a,b两个页面,引入相同资源,但a有使用manifest,而b没有.那么,即使a页面缓存了资源.b页面也不会有效.而且b页面强制更新了资源.a页面的缓存也不会因为b的更新，而更新</li>
	<li>a页面引入manifest,缓存的资源, 在浏览器地址栏中直接访问,则也命中offline application的缓存.刷新也如此.至少chrome,FF都是如此实现的</li>
	<li>a,b两个页面,分别引入A,B两个manifest文件,且分别缓存相同的一个资源R,则 如果此时更新R,然后更新B.则.b刷新后重新获取资源R,但是a的R资源缓存副本是不会被更新的.</li>
	<li>a,b两个页面,引用同一份manifest A. 则更新A,更新R,刷新b, b对应的R资源更新后,a的R资源副本也会随之更新. 这就是cache group的机制.因为a和b对应的application cache,同属于同一个application cache group.. 建议为manifest文件配置304相关 头域时,也配置expires和cache-control : max-age.因为chrome,safari,以及android,只有304相关头域，而没有expires 或 max-age时,不会有304，而只会是200, opera则无视一切http cache头域.总是200</li>
	<li>(浏览器的实现都有问题,webkit的问题是,没有遵守http协议.因为304相关头域是足矣使浏览器是具备资源副本,并做握手的. 而opera则完全无视http缓存头域.更加不靠谱. (IE10 pp2,FF系列.不方便测试))</li>
</ol>
