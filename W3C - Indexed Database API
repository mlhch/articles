<h1>W3C - Indexed Database API</h1>

<p>2014-02-23 20:47 Sunday</p>

<p><a href="http://www.w3.org/TR/IndexedDB/" target="_blank">http://www.w3.org/TR/IndexedDB/</a></p>

<p>HTML5 的一个重要特性是本地数据持久性，它使用户能够在线和离线访问 Web 应用程序。此外，本地数据持久性使移动应用程序更灵敏，使用的带宽更少，而且能够在低带宽场景中更高效地工作。HTML5 提供了一些本地数据持久性选项。第一个选项是&nbsp;localstorage，它支持您使用一个简单的键值对来存储数据。IndexedDB（一个更加强大的选项）支持您本地存储大量对象，并使用健壮的数据访问机制检索数据。</p>

<p>IndexedDB API 取代了 Web Storage API，后者在 HTML5 规范中已不推荐使用。（但一些领先的浏览器仍然支持 Web Storage，其中包括苹果公司的 Safari 和 Opera Web 浏览器）与 Web Storage 相比，IndexedDB 具有多个优势，其中包括索引、事务处理和健壮的查询功能。</p>

<h2>IndexedDB 是什么？</h2>

<p>IndexedDB 是对象存储，它不同于带有表格（包含行和列的集合）的关系数据库。这是一个重要的根本区别，并且会影响您设计和构建应用的方式。</p>

<h2>为什么是 IndexedDB？</h2>

<p>在 2010 年 11 月 18 日，<a href="http://www.w3.org/TR/webdatabase/">W3C 宣布</a>弃用 Web SQL 数据库规范。这也就是建议网络开发人员不要再使用这种技术了，该规范也不会再获得新的更新，而且不鼓励浏览器供应商支持该技术。</p>

<h2>MDN&nbsp;-&nbsp;MDN中文&nbsp;-&nbsp;IndexedDB</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/IndexedDB" target="_blank">https://developer.mozilla.org/zh-CN/docs/IndexedDB</a></p>

<h3>存储空间限制</h3>

<p>一个单独的数据库项目的大小没有限制。然而可能会限制每个 IndexedDB 数据库的大小。这个限制（以及用户界面对它进行断言的方式）在各个浏览器上也可能有所不同：</p>

<ul>
	<li>
	<p>Firefox: 对 IndexedDB 数据库的大小没有限制。在用户界面上只会针对存储超过 50 MB 大小的 BLOB（二进制大对象）请求权限。这个大小的限额可以通过&nbsp;dom.indexedDB.warningQuota&nbsp;首选项进行自定义 (定义在&nbsp;<a href="http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js">http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js</a>)。</p>
	</li>
	<li>Google Chrome: 参见&nbsp;<a href="https://developers.google.com/chrome/whitepapers/storage#temporary">https://developers.google.com/chrome...rage#temporary</a></li>
</ul>

<h2>探索和实践</h2>

<p><a href="http://javascript.ruanyifeng.com/bom/indexeddb.html" target="_blank">http://javascript.ruanyifeng.com/bom/indexeddb.html</a></p>

<h3>概述</h3>

<p>随着浏览器的处理能力不能增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少用户等待从服务器获取数据的时间。</p>

<p>现有的浏览器端数据储存方案，都不适合储存大量数据：cookie不超过4KB，且每次请求都会发送回服务器端；Window.name属性缺乏安全性，且没有统一的标准；localStorage在2.5MB到10MB之间（各家浏览器不同）。所以，需要一种新的解决方案，这就是IndexedDB诞生的背景。</p>

<p>通俗地说，IndexedDB就是浏览器端数据库，可以被网页脚本程序创建和操作。它允许储存大量数据，提供查找接口，还能建立索引。这些都是localStorage所不具备的。就数据库类型而言，IndexedDB不属于关系型数据库（不支持SQL查询语句），更接近NoSQL数据库。</p>

<p>IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。在对象仓库中，数据以&ldquo;键值对&rdquo;的形式保存，每一个数据都有对应的键名，键名是独一无二的，不能有重复，否则会抛出一个错误。</p>

<p>IndexedDB也受到同域限制，每一个数据库对应创建该数据库的域名。来自不同域名的网页，只能访问自身域名下的数据库，而不能访问其他域名下的数据库。</p>

<p>目前，Chrome 27+、Firefox 21+、Opera 15+和IE 10+支持这个API。可以说，它在桌面端有良好的支持，但是移动端支持这个API的浏览器还不多。</p>

<p>下面的代码用来检查浏览器是否支持这个API。</p>

<pre>
if(&quot;indexedDB&quot; in window) {
        console.log(&quot;支持&quot;);
    } else {
        console.log(&quot;不支持&quot;);
    }
}</pre>

<h3>open方法</h3>

<p>indexedDB.open方法用于打开数据库。</p>

<pre>
var openRequest = indexedDB.open(&quot;test&quot;, 1);</pre>

<p>open方法的第一个参数是数据库名称，第二个参数是数据库版本。上面代码代码表示，打开一个名为test、版本为1的数据库。</p>

<p>打开数据库的结果是，有可能触发4种事件。</p>

<ul>
	<li>success：打开成功。</li>
	<li>error：打开失败。</li>
	<li>upgradeneeded：第一次打开该数据库，或者数据库版本发生变化。</li>
	<li>blocked：上一次的数据库连接还未关闭。</li>
</ul>

<p>第一次打开数据库时，会先触发upgradeneeded事件，然后触发success事件。</p>

<p>根据不同的需要，对上面4种事件设立回调函数。</p>

<pre>
var openRequest = indexedDB.open(&quot;test&quot;,1);

openRequest.onupgradeneeded = function(e) {
    console.log(&quot;Upgrading...&quot;);
    var objectStore = event.target.result.createObjectStore(&quot;tiles&quot;);
&nbsp;&nbsp; &nbsp;console.log(objectStore)
}
 
openRequest.onsuccess = function(event) {
&nbsp;&nbsp; &nbsp;var db = event.target.result;
&nbsp;&nbsp; &nbsp;console.log(db);
    var trans = db.transaction(&#39;tiles&#39;);
&nbsp;&nbsp; &nbsp;var store = trans.objectStore(&#39;tiles&#39;);
}
 
openRequest.onerror = function(e) {
    console.log(&quot;Error&quot;);
    console.dir(e);
}
</pre>

<p>上面代码显示，回调函数接受一个事件对象event作为参数。event对象的target.result属性就指向IndexedDB数据库。</p>

<h3>需留意：</h3>

<ul>
	<li>
	<p>db 的打印结果是：</p>

	<pre>
IDBDatabase
  name: &quot;maptiles&quot;
  <span class="marker">objectStoreNames: DOMStringList
&nbsp;   0: &quot;tiles&quot;
&nbsp;   length: 1</span>
  onabort: null
  onclose: null
  onerror: null
  onversionchange: null
  version: 3
  __proto__: IDBDatabase
    close: function close() { [native code] }
    constructor: function IDBDatabase() { [native code] }
    createObjectStore: function createObjectStore() { [native code] }
    deleteObjectStore: function deleteObjectStore() { [native code] }
    transaction: function transaction() { [native code] }
    __proto__: EventTarget</pre>
	</li>
	<li>createObjectStore 方法的调用必须放在&nbsp;onupgradeneeded 方法中，而只有提高 open 方法中的版本参数才会触发此方法的调用。否则会提示错误：</li>
	<li>
	<p>trans 的打印结果：</p>

	<pre>
IDBTransaction
  db: IDBDatabase
  error: null
  mode: &quot;readonly&quot;
  onabort: null
  oncomplete: null
  onerror: null
  __proto__: IDBTransaction
    abort: function abort() { [native code] }
    constructor: function IDBTransaction() { [native code] }
    objectStore: function objectStore() { [native code] }
    __proto__: EventTarget</pre>
	</li>
	<li>
	<p>store 的打印结果</p>

	<pre>
IDBObjectStore
  autoIncrement: false
  indexNames: DOMStringList
  keyPath: null
  name: &quot;tiles&quot;
  transaction: IDBTransaction
  __proto__: IDBObjectStore
    add: function add() { [native code] }
    clear: function clear() { [native code] }
    constructor: function IDBObjectStore() { [native code] }
    count: function count() { [native code] }
    createIndex: function createIndex() { [native code] }
    delete: function delete() { [native code] }
    deleteIndex: function deleteIndex() { [native code] }
    get: function get() { [native code] }
    index: function index() { [native code] }
    openCursor: function openCursor() { [native code] }
    put: function put() { [native code] }
    __proto__: Object</pre>
	</li>
</ul>

<p>&nbsp;</p>

<h3>transaction方法</h3>

<p>transaction方法用于创建一个数据库事务。向数据库添加数据之前，必须先创建数据库事务。</p>

<pre>
var t = db.transaction([&quot;firstOS&quot;],&quot;readwrite&quot;);
</pre>

<p>transaction方法接受两个参数：第一个参数是一个数组，里面是所涉及的对象仓库，通常是只有一个；第二个参数是一个表示操作类型的字符串。目前，操作类型只有两种：readonly（只读）和readwrite（读写）。添加数据使用readwrite，读取数据使用readonly。</p>

<p>transaction方法返回一个事务对象，该对象的objectStore方法用于获取指定的对象仓库。</p>

<pre>
var t = db.transaction([&quot;firstOS&quot;],&quot;readwrite&quot;);

var store = t.objectStore(&quot;firstOS&quot;);
</pre>

<p>transaction方法有三个事件，可以用来定义回调函数。</p>
