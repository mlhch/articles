<h1>Docker</h1>

<p>2016-04-03 00:39:29 Sunday</p>

<p><a href="https://www.docker.com/" target="_blank">https://www.docker.com/</a>&nbsp;|&nbsp;<a href="http://www.docker.org.cn/" target="_blank">http://www.docker.org.cn/</a></p>

<blockquote>
<p>Build, Ship, Run</p>
</blockquote>

<p>An open platform for distributed applications for developers and sysadmins</p>

<h2>概念</h2>

<p>docker 在 Linux 上原生支持，所以无需借助&nbsp;docker-machine。在 Windows 或者 OSX 上则需要 docker-machine 创建 Linux&nbsp;虚拟机来得到支持。</p>

<p>用 brew 安装 docker 和 docker-machine。docker-machine 命令是 boot2docker 命令的替代，用来创建并管理 machine，供 docker 命令使用。</p>

<p>`docker pull &lt;repo&gt; 得到的是 image，`docker rmi &lt;image id&gt;` 可删除 image，`docker images` 可列出本地所有 image</p>

<p>`docker ps -a` 列出的是所有 container，`docker rm &lt;container id&gt;` 可删除 container。</p>

<h2>VirtualBox 目录映射</h2>

<p>2016-04-05 20:46 Tuesday</p>

<p>默认 /Users 已经映射，但其他目录的映射需要如下步骤来实现</p>

<ol>
	<li>通过 VirtualBox 的图形界面 &ldquo;设置&rdquo; -&gt; &ldquo;共享文件夹&rdquo; 手动添加共享文件夹路径 /WORK</li>
	<li>进入虚拟机实例，执行命令 `sudo VBoxControl sharedfolder list`&nbsp;确认 /WORK 目录已经被识别</li>
	<li>手动创建被映射目录：`sudo mkdir /WORK`</li>
	<li>手动挂载：`sudo mount -t vboxsf WORK /WORK`</li>
</ol>

<h2>安装</h2>

<p>https://www.docker.com/products/docker-toolbox</p>

<p>brew 安装的版本与官网下载的版本一致。</p>

<pre>
$ brew install docker
==&gt; Downloading https://homebrew.bintray.com/bottles/docker-1.10.3.el_capitan.bottle.tar.gz
######################################################################## 100.0%
==&gt; Pouring docker-1.10.3.el_capitan.bottle.tar.gz
==&gt; Caveats
Bash completion has been installed to:
  /usr/local/etc/bash_completion.d

zsh completion has been installed to:
  /usr/local/share/zsh/site-functions
==&gt; Summary
🍺  /usr/local/Cellar/docker/1.10.3: 10 files, 11.2M</pre>

<pre>
$ docker -v
Docker version 1.10.3, build 20f81dd
</pre>

<pre>
$ brew install docker-machine
==&gt; Downloading https://homebrew.bintray.com/bottles/docker-machine-0.6.0.el_capitan.bottle.tar.gz
Already downloaded: /Library/Caches/Homebrew/docker-machine-0.6.0.el_capitan.bottle.tar.gz
==&gt; Pouring docker-machine-0.6.0.el_capitan.bottle.tar.gz
==&gt; Caveats
Bash completion has been installed to:
&nbsp; /usr/local/etc/bash_completion.d
==&gt; Summary
🍺 &nbsp;/usr/local/Cellar/docker-machine/0.6.0: 5 files, 36.8M
</pre>

<h2>使用</h2>

<h3>Use Machine to run Docker containers</h3>

<p>https://docs.docker.com/machine/get-started/</p>

<h4>Prerequisites</h4>

<ul>
	<li>
	<p>Make sure you have&nbsp;<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank">the latest VirtualBox</a>&nbsp;correctly installed on your system. If you used&nbsp;<a href="https://www.docker.com/products/docker-toolbox" target="_blank">Toolbox</a>&nbsp;for&nbsp;<a href="https://docs.docker.com/engine/installation/mac/" target="_blank">Mac</a>&nbsp;or&nbsp;<a href="https://docs.docker.com/engine/installation/windows/" target="_blank">Windows</a>&nbsp;to install Docker Machine, VirtualBox is automatically installed.</p>
	</li>
	<li>
	<p>If you used the Quickstart Terminal to launch your first machine and set your terminal environment to point to it, a default machine was automatically created. If this is the case, you can still follow along with these steps, but create another machine and name it something other than &ldquo;default&rdquo; (e.g., staging or sandbox).</p>
	</li>
</ul>

<p>查看是现有 machines</p>

<pre>
$ docker-machine ls
NAME &nbsp; ACTIVE &nbsp; DRIVER &nbsp; STATE &nbsp; URL &nbsp; SWARM &nbsp; DOCKER &nbsp; ERRORS
</pre>

<p>创建 machine</p>

<pre>
$ docker-machine create --driver virtualbox default
Creating CA: ~/.docker/machine/certs/ca.pem
Creating client certificate: ~/.docker/machine/certs/cert.pem
Running pre-create checks...
(default) Image cache directory does not exist, creating it at ~/.docker/machine/cache...
(default) No default Boot2Docker ISO found locally, downloading the latest release...
(default) Latest release for github.com/boot2docker/boot2docker is v1.10.3
(default) Downloading ~/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v1.10.3/boot2docker.iso...</pre>

<p>此处视网速会停滞许久，不如手动下载后放到&nbsp;~/.docker/machine/cache/boot2docker.iso</p>

<pre>
$ docker-machine create --driver virtualbox default
Running pre-create checks...
Creating machine...
(default) Copying ~/.docker/machine/cache/boot2docker.iso to ~/.docker/machine/machines/default/boot2docker.iso...
(default) Creating VirtualBox VM...
(default) Creating SSH key...
(default) Starting the VM...
(default) Check network to re-create if needed...
(default) Found a new host-only adapter: &quot;vboxnet1&quot;
(default) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env default
</pre>

<p>再查看 machines 就有了刚创建的&nbsp;machine 了</p>

<pre>
$ docker-machine ls
NAME &nbsp; &nbsp; &nbsp;ACTIVE &nbsp; DRIVER &nbsp; &nbsp; &nbsp; STATE &nbsp; &nbsp; URL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SWARM &nbsp; DOCKER &nbsp; &nbsp;ERRORS
default &nbsp; - &nbsp; &nbsp; &nbsp; &nbsp;virtualbox &nbsp; Running &nbsp; tcp://192.168.99.100:2376 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v1.10.3
</pre>

<p>查看 default 这个 machine 的一些信息</p>

<pre>
$ docker-machine env default
export DOCKER_TLS_VERIFY=&quot;1&quot;
export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;
export DOCKER_CERT_PATH=&quot;/Users/mlhch/.docker/machine/machines/default&quot;
export DOCKER_MACHINE_NAME=&quot;default&quot;
# Run this command to configure your shell:&nbsp;
# eval $(docker-machine env default)</pre>

<p>把上述输出当作 bash 脚本执行后，其中的环境变量就可用了</p>

<pre>
$ eval $(docker-machine env default)
</pre>

<p>ssh 就这样登录了，不需要用户名和密码</p>

<pre>
$ docker-machine ssh
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ## &nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ## ## ## &nbsp; &nbsp; &nbsp; &nbsp;==
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;## ## ## ## ## &nbsp; &nbsp;===
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___/ ===
&nbsp; &nbsp; &nbsp; ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ / &nbsp;===- ~~~
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\______ o &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __/
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\ &nbsp; &nbsp;\ &nbsp; &nbsp; &nbsp; &nbsp; __/
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \____\_______/
&nbsp;_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ &nbsp; ____ &nbsp; &nbsp; _ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_
| |__ &nbsp; ___ &nbsp; ___ | |_|___ \ __| | ___ &nbsp; ___| | _____ _ __
| &#39;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &#39;__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__| &nbsp; &lt; &nbsp;__/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
Boot2Docker version 1.10.3, build master : 625117e - Thu Mar 10 22:09:02 UTC 2016
Docker version 1.10.3, build 20f81dd</pre>

<h2>php-zendserver</h2>

<p>2016-04-04 22:35 Monday 老婆带着朵朵跟着岳父岳母回了</p>

<p>https://hub.docker.com/_/php-zendserver/</p>

<pre>
$ docker pull php-zendserver
</pre>

<p>此步执行后则可看到多了一个 image f719</p>

<pre>
$ docker images
REPOSITORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IMAGE ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CREATED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SIZE
php-zendserver &nbsp; &nbsp; &nbsp;latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f7193503fb87 &nbsp; &nbsp; &nbsp; &nbsp;2 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 754.2 MB
nginx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;af4b3d7d5401 &nbsp; &nbsp; &nbsp; &nbsp;3 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 190.5 MB</pre>

<p>如下命令是阻断式的，无法 Ctrl+C 结束，只能通过 docker ps 查看到&nbsp;CONTAINER ID，然后</p>

<pre>
$ docker run -p 88:80 -p 10088:10081 php-zendserver
Zend Server initialization result: success.
Zend Server is ready for use
Your application is available at http://172.17.0.2
To access Zend Server, navigate to http://172.17.0.2:10081
Your admin password is MzFhNzY1
</pre>

<p>此时真正能访问的地址是 http://`docker-machine ip`:88 和 http://`docker-machine ip`:10088</p>

<p>可惜&nbsp;YOUR ZEND SERVER LICENSE HAS EXPIRED.</p>

<h2>php</h2>

<p>2015-04-05 16:04 Tuesday 今天租房的事情算是搞定了</p>

<p>观察到 fdd5d 已经存在，可推想是&ldquo;分层缓存&rdquo;在起作用，不同的 image 有着共同的祖先</p>

<pre>
$ docker pull php
Using default tag: latest
latest: Pulling from library/php

fdd5d7827f33: Already exists&nbsp;
a3ed95caeb02: Pull complete&nbsp;
2f584a474c46: Pull complete&nbsp;
b185147d01c6: Pull complete&nbsp;
6663e6f16e95: Pull complete&nbsp;
fd91f8bf39df: Pull complete&nbsp;
6d7c00c29f57: Pull complete&nbsp;
Digest: sha256:a98c4203f8d463ddc018948931ce70df4dd2204c3394cc183a5cc1f38b799c81
Status: Downloaded newer image for php:latest</pre>

<pre>
$ docker images
REPOSITORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IMAGE ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CREATED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SIZE
php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8c8eb06f7c64 &nbsp; &nbsp; &nbsp; &nbsp;2 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 483.8 MB
php-zendserver &nbsp; &nbsp; &nbsp;latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f7193503fb87 &nbsp; &nbsp; &nbsp; &nbsp;2 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 754.2 MB
nginx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;af4b3d7d5401 &nbsp; &nbsp; &nbsp; &nbsp;3 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 190.5 MB
</pre>

<p>测试一：--rm 表示执行完后立即删除 container，第一个 php 是 image，第二个 php 是 container 中的 php 可执行命令</p>

<pre>
$ docker run -it --rm php php --version
PHP 7.0.4 (cli) (built: Mar 19 2016 00:06:16) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
</pre>

<p>测试二：-v 表示目录映射，需要注意的是，$PWD 指的并不是 OSX 上本机当前路径，而是 docker-machine 上的当前路径。当 $PWD 位于 VirtualBox 默认挂载的共享目录 /Users 之外时，就需要手动挂载 OSX 上的当前路径，比如 /WORK 到 docker-machine 上的 /WORK，如此 OSX 上位于 /WORK 之下的 $PWD 就和 docker-machine 上的 $PWD 对应起来了。-w 表示切换工作目录到指定目录。</p>

<pre>
$ docker run --rm -v &quot;$PWD&quot;:/var/www/aaa -w /var/www/aaa php ls -al
</pre>

<h2>mysql</h2>

<p>2016-04-07 08:47&nbsp;Thursday 昨天收拾好了工作室的彩钢屋</p>

<p>https://hub.docker.com/_/mysql/</p>

<pre>
$ docker pull mysql:5.5
</pre>

<p>不加 -d 时，前台运行，但不响应&nbsp;Ctrl+C，所以还是加 -d 方便，但前台运行方便观察错误信息。--name 给它起个好记的名字，方便随后引用。-p 把 container 的 3306 映射到 &nbsp;docker-machine 的 3306，这样方便其它 container 连接。-v 把 docker-machine 上映射好的 /mysqldata&nbsp;挂载到 container 默认的 mysql 的&nbsp;data_dir（/var/lib/mysql）。/mysqldata 一定需要可写，通过 mount 时设定 uid=999 来实现，999 是&nbsp;container 中 mysql 用户的 id，可登录 container 查看 /etc/passwd 得到。此处单独给 mysql 映射并挂载是因为 /WORK 目录为了可写已经挂载为 docker(uid=1000) 用户，/WORK/databases/mysqldata 受此影响也属于&nbsp;docker 用户。</p>

<pre>
$ docker run -d --name mysql55 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=aaaa -v /mysqldata:/var/lib/mysql:rw mysql:5.5</pre>

<p>测试方式一，其中 mysql55 是上句中给生成的 container 的命名</p>

<pre>
$ docker exec -it mysql55 bash&nbsp;</pre>

<p>测试方式二，其中&nbsp;mysql55 是之前生成的 container 的名字，-h 的地址是 &nbsp;container 的真正地址，而不是 docker-machine 的地址，但如果 -p 映射过的话，就可以用 docker-machine 的地址了。</p>

<pre>
$ docker run -it --link mysql55:mysql --rm mysql:5.5 sh -c &#39;exec mysql -h&quot;172.17.0.3&quot; -P&quot;3306&quot; -uroot -p&quot;aaaa&quot;&#39;
</pre>

<h2>What is Docker Machine?</h2>

<blockquote>
<p>boot2docker -&gt; Docker Machine</p>

<p>https://github.com/boot2docker/boot2docker-cli -&gt; https://docs.docker.com/machine/</p>
</blockquote>

<p>Docker Machine is a tool that lets you install Docker Engine on virtual hosts, and manage the hosts with&nbsp;<code>docker-machine</code>&nbsp;commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like AWS or Digital Ocean.</p>

<p>Docker Machine 是一个工具，用来在虚拟机上安装并管理 Docker Engine。</p>

<p>Using&nbsp;<code>docker-machine</code>&nbsp;commands, you can start, inspect, stop, and restart a managed host, upgrade the Docker client and daemon, and configure a Docker client to talk to your host.</p>

<p>使用 docker-machine 命令行，你可以启动，监视，停止和重启一个被管理的主机。</p>

<p>Point the Machine CLI at a running, managed host, and you can run<code>docker</code>&nbsp;commands directly on that host. For example, run<code>docker-machine env default</code>&nbsp;to point to a host called&nbsp;<code>default</code>, follow on-screen instructions to complete&nbsp;<code>env</code>&nbsp;setup, and run&nbsp;<code>docker ps</code>,<code>docker run hello-world</code>, and so forth.</p>
