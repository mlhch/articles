<h1>Docker</h1>

<p>2016-04-03 00:39:29 Sunday</p>

<p><a href="https://www.docker.com/" target="_blank">https://www.docker.com/</a>&nbsp;|&nbsp;<a href="http://www.docker.org.cn/" target="_blank">http://www.docker.org.cn/</a></p>

<blockquote>
<p>Build, Ship, Run</p>
</blockquote>

<p>An open platform for distributed applications for developers and sysadmins</p>

<h2>概念</h2>

<p>docker 在 Linux 上原生支持，所以无需借助&nbsp;docker-machine。在 Windows 或者 OSX 上则需要 docker-machine 创建 Linux&nbsp;虚拟机来得到支持。</p>

<p>用 brew 安装 docker 和 docker-machine。docker-machine 命令是 boot2docker 命令的替代，用来创建并管理 machine，供 docker 命令使用。</p>

<p>`docker pull &lt;repo&gt; 得到的是 image，`docker rmi &lt;image id&gt;` 可删除 image，`docker images` 可列出本地所有 image</p>

<p>`docker ps -a` 列出的是所有 container，`docker rm &lt;container id&gt;` 可删除 container。</p>

<h2>VirtualBox 网卡配置</h2>

<p>2016-06-23 22:17 Thursday</p>

<p>刚刚 fm start 报错：Error checking TLS connection: Error checking and/or regenerating the certs，想来是因为最近为了让手机能够访问 docker 中的服务而添加了第三块网卡，以及相关的一些乱操作导致。折腾了一会通过 fm ls 发现 fm start 一直得不到 IP 是因为执行了命令 ip addr show dev eth1，而 eth1 对应的就是 VirtualBox 中的第二块网卡。因此 eth0 对应的第一块网卡必须有效，记得原来是&ldquo;网络地址转换（NAT）&rdquo;。然后第二块网卡选择&ldquo;仅主机（Host-Only）适配器&rdquo;后就太平了。</p>

<p>2016-07-10 13:25 Sunday 早上10000来电说外网 ip 准备好了。今天必须得在家打扫卫生了</p>

<p>绕了半天，一直困惑于为什么本机连上了 VPN，docker-machine 却对外显示还是原来的 IP，原来是因为那块在 VirtualBox 里手动添加的第三块桥接模式的网卡！！白折腾 OSX 上的 route 命令了。不过有机会倒是可继续研究 netstat -nr 列出的路由表。</p>

<p>早上查到 docker 有个工具叫 pipework，可以方便地把某个窗口桥接到主机所在网络，这个太神了，有机会再研究。</p>

<h2>VirtualBox 目录映射</h2>

<p>2016-04-05 20:46 Tuesday</p>

<p>默认 /Users 已经映射，但其他目录的映射需要如下步骤来实现</p>

<ol>
	<li>通过 VirtualBox 的图形界面 &ldquo;设置&rdquo; -&gt; &ldquo;共享文件夹&rdquo; 手动添加共享文件夹路径 /WORK</li>
	<li>进入虚拟机实例，执行命令 `sudo VBoxControl sharedfolder list`&nbsp;确认 /WORK 目录已经被识别</li>
	<li>手动创建被映射目录：`sudo mkdir /WORK`</li>
	<li>手动挂载：`sudo mount -t vboxsf WORK /WORK`</li>
</ol>

<p>2016-07-05 15:40 Tuesday</p>

<p>折腾了两三天&nbsp;Wordpress，发现 docker 的性能相当差，原因在于 vboxsf 这个 VirtualBox 的共享文件系统。代之以 NFS，性能果然有了明显的提升，基本上无插件的 Wordpress 首页从 2 秒多变成了 1 秒以下</p>

<pre>
## -mask requires -net
## -mapall=mlhch 的意思是，把远程所有用户都当作本地的 mlhch 用户，拥有 mlhch 用户的权限
/WORK 192.168.99.100 -alldirs -mapall=mlhch</pre>

<p>然后在 docker-machine 中挂载</p>

<pre>
## http://nfs.sourceforge.net/nfs-howto/ar01s05.html
## rsize and wsize
sudo mount 192.168.99.1:/WORK /WORK -o rw,async,noatime,rsize=32768,wsize=32768,proto=tcp
</pre>

<h2>安装</h2>

<p>https://www.docker.com/products/docker-toolbox</p>

<p>brew 安装的版本与官网下载的版本一致。</p>

<pre>
$ brew install docker
==&gt; Downloading https://homebrew.bintray.com/bottles/docker-1.10.3.el_capitan.bottle.tar.gz
######################################################################## 100.0%
==&gt; Pouring docker-1.10.3.el_capitan.bottle.tar.gz
==&gt; Caveats
Bash completion has been installed to:
  /usr/local/etc/bash_completion.d

zsh completion has been installed to:
  /usr/local/share/zsh/site-functions
==&gt; Summary
🍺  /usr/local/Cellar/docker/1.10.3: 10 files, 11.2M</pre>

<pre>
$ docker -v
Docker version 1.10.3, build 20f81dd
</pre>

<pre>
$ brew install docker-machine
==&gt; Downloading https://homebrew.bintray.com/bottles/docker-machine-0.6.0.el_capitan.bottle.tar.gz
Already downloaded: /Library/Caches/Homebrew/docker-machine-0.6.0.el_capitan.bottle.tar.gz
==&gt; Pouring docker-machine-0.6.0.el_capitan.bottle.tar.gz
==&gt; Caveats
Bash completion has been installed to:
&nbsp; /usr/local/etc/bash_completion.d
==&gt; Summary
🍺 &nbsp;/usr/local/Cellar/docker-machine/0.6.0: 5 files, 36.8M
</pre>

<h2>使用</h2>

<h3>Use Machine to run Docker containers</h3>

<p>https://docs.docker.com/machine/get-started/</p>

<h4>Prerequisites</h4>

<ul>
	<li>
	<p>Make sure you have&nbsp;<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank">the latest VirtualBox</a>&nbsp;correctly installed on your system. If you used&nbsp;<a href="https://www.docker.com/products/docker-toolbox" target="_blank">Toolbox</a>&nbsp;for&nbsp;<a href="https://docs.docker.com/engine/installation/mac/" target="_blank">Mac</a>&nbsp;or&nbsp;<a href="https://docs.docker.com/engine/installation/windows/" target="_blank">Windows</a>&nbsp;to install Docker Machine, VirtualBox is automatically installed.</p>
	</li>
	<li>
	<p>If you used the Quickstart Terminal to launch your first machine and set your terminal environment to point to it, a default machine was automatically created. If this is the case, you can still follow along with these steps, but create another machine and name it something other than &ldquo;default&rdquo; (e.g., staging or sandbox).</p>
	</li>
</ul>

<p>查看是现有 machines</p>

<pre>
$ docker-machine ls
NAME &nbsp; ACTIVE &nbsp; DRIVER &nbsp; STATE &nbsp; URL &nbsp; SWARM &nbsp; DOCKER &nbsp; ERRORS
</pre>

<p>创建 machine</p>

<pre>
$ docker-machine create --driver virtualbox default
Creating CA: ~/.docker/machine/certs/ca.pem
Creating client certificate: ~/.docker/machine/certs/cert.pem
Running pre-create checks...
(default) Image cache directory does not exist, creating it at ~/.docker/machine/cache...
(default) No default Boot2Docker ISO found locally, downloading the latest release...
(default) Latest release for github.com/boot2docker/boot2docker is v1.10.3
(default) Downloading ~/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v1.10.3/boot2docker.iso...</pre>

<p>此处视网速会停滞许久，不如手动下载后放到&nbsp;~/.docker/machine/cache/boot2docker.iso</p>

<pre>
$ docker-machine create --driver virtualbox default
Running pre-create checks...
Creating machine...
(default) Copying ~/.docker/machine/cache/boot2docker.iso to ~/.docker/machine/machines/default/boot2docker.iso...
(default) Creating VirtualBox VM...
(default) Creating SSH key...
(default) Starting the VM...
(default) Check network to re-create if needed...
(default) Found a new host-only adapter: &quot;vboxnet1&quot;
(default) Waiting for an IP...
Waiting for machine to be running, this may take a few minutes...
Detecting operating system of created instance...
Waiting for SSH to be available...
Detecting the provisioner...
Provisioning with boot2docker...
Copying certs to the local machine directory...
Copying certs to the remote machine...
Setting Docker configuration on the remote daemon...
Checking connection to Docker...
Docker is up and running!
To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env default
</pre>

<p>再查看 machines 就有了刚创建的&nbsp;machine 了</p>

<pre>
$ docker-machine ls
NAME &nbsp; &nbsp; &nbsp;ACTIVE &nbsp; DRIVER &nbsp; &nbsp; &nbsp; STATE &nbsp; &nbsp; URL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SWARM &nbsp; DOCKER &nbsp; &nbsp;ERRORS
default &nbsp; - &nbsp; &nbsp; &nbsp; &nbsp;virtualbox &nbsp; Running &nbsp; tcp://192.168.99.100:2376 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v1.10.3
</pre>

<p>查看 default 这个 machine 的一些信息</p>

<pre>
$ docker-machine env default
export DOCKER_TLS_VERIFY=&quot;1&quot;
export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;
export DOCKER_CERT_PATH=&quot;/Users/mlhch/.docker/machine/machines/default&quot;
export DOCKER_MACHINE_NAME=&quot;default&quot;
# Run this command to configure your shell:&nbsp;
# eval $(docker-machine env default)</pre>

<p>把上述输出当作 bash 脚本执行后，其中的环境变量就可用了</p>

<pre>
$ eval $(docker-machine env default)
</pre>

<p>ssh 就这样登录了，不需要用户名和密码</p>

<pre>
$ docker-machine ssh
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ## &nbsp; &nbsp; &nbsp; &nbsp; .
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ## ## ## &nbsp; &nbsp; &nbsp; &nbsp;==
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;## ## ## ## ## &nbsp; &nbsp;===
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___/ ===
&nbsp; &nbsp; &nbsp; ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ / &nbsp;===- ~~~
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\______ o &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __/
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\ &nbsp; &nbsp;\ &nbsp; &nbsp; &nbsp; &nbsp; __/
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \____\_______/
&nbsp;_ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ &nbsp; ____ &nbsp; &nbsp; _ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_
| |__ &nbsp; ___ &nbsp; ___ | |_|___ \ __| | ___ &nbsp; ___| | _____ _ __
| &#39;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &#39;__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__| &nbsp; &lt; &nbsp;__/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
Boot2Docker version 1.10.3, build master : 625117e - Thu Mar 10 22:09:02 UTC 2016
Docker version 1.10.3, build 20f81dd</pre>

<h2>php-zendserver</h2>

<p>2016-04-04 22:35 Monday 老婆带着朵朵跟着岳父岳母回了</p>

<p>https://hub.docker.com/_/php-zendserver/</p>

<pre>
$ docker pull php-zendserver
</pre>

<p>此步执行后则可看到多了一个 image f719</p>

<pre>
$ docker images
REPOSITORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IMAGE ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CREATED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SIZE
php-zendserver &nbsp; &nbsp; &nbsp;latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f7193503fb87 &nbsp; &nbsp; &nbsp; &nbsp;2 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 754.2 MB
nginx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;af4b3d7d5401 &nbsp; &nbsp; &nbsp; &nbsp;3 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 190.5 MB</pre>

<p>如下命令是阻断式的，无法 Ctrl+C 结束，只能通过 docker ps 查看到&nbsp;CONTAINER ID，然后</p>

<pre>
$ docker run -p 88:80 -p 10088:10081 php-zendserver
Zend Server initialization result: success.
Zend Server is ready for use
Your application is available at http://172.17.0.2
To access Zend Server, navigate to http://172.17.0.2:10081
Your admin password is MzFhNzY1
</pre>

<p>此时真正能访问的地址是 http://`docker-machine ip`:88 和 http://`docker-machine ip`:10088</p>

<p>可惜&nbsp;YOUR ZEND SERVER LICENSE HAS EXPIRED.</p>

<h2>php</h2>

<p>2015-04-05 16:04 Tuesday 今天租房的事情算是搞定了</p>

<p>观察到 fdd5d 已经存在，可推想是&ldquo;分层缓存&rdquo;在起作用，不同的 image 有着共同的祖先</p>

<pre>
$ docker pull php
Using default tag: latest
latest: Pulling from library/php

fdd5d7827f33: Already exists&nbsp;
a3ed95caeb02: Pull complete&nbsp;
2f584a474c46: Pull complete&nbsp;
b185147d01c6: Pull complete&nbsp;
6663e6f16e95: Pull complete&nbsp;
fd91f8bf39df: Pull complete&nbsp;
6d7c00c29f57: Pull complete&nbsp;
Digest: sha256:a98c4203f8d463ddc018948931ce70df4dd2204c3394cc183a5cc1f38b799c81
Status: Downloaded newer image for php:latest</pre>

<pre>
$ docker images
REPOSITORY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IMAGE ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CREATED &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SIZE
php &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8c8eb06f7c64 &nbsp; &nbsp; &nbsp; &nbsp;2 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 483.8 MB
php-zendserver &nbsp; &nbsp; &nbsp;latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f7193503fb87 &nbsp; &nbsp; &nbsp; &nbsp;2 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 754.2 MB
nginx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;af4b3d7d5401 &nbsp; &nbsp; &nbsp; &nbsp;3 weeks ago &nbsp; &nbsp; &nbsp; &nbsp; 190.5 MB
</pre>

<p>测试一：--rm 表示执行完后立即删除 container，第一个 php 是 image，第二个 php 是 container 中的 php 可执行命令</p>

<pre>
$ docker run -it --rm php php --version
PHP 7.0.4 (cli) (built: Mar 19 2016 00:06:16) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
</pre>

<p>测试二：-v 表示目录映射，需要注意的是，$PWD 指的并不是 OSX 上本机当前路径，而是 docker-machine 上的当前路径。当 $PWD 位于 VirtualBox 默认挂载的共享目录 /Users 之外时，就需要手动挂载 OSX 上的当前路径，比如 /WORK 到 docker-machine 上的 /WORK，如此 OSX 上位于 /WORK 之下的 $PWD 就和 docker-machine 上的 $PWD 对应起来了。-w 表示切换工作目录到指定目录。</p>

<pre>
$ docker run --rm -v &quot;$PWD&quot;:/var/www/aaa -w /var/www/aaa php ls -al
</pre>

<h2>apache/httpd+php</h2>

<p>2016-04-10 16:16 Sunday</p>

<p>官方 httpd 映像默认把 apache2 安装在 /usr/local/apache2，apt-get install libapache2-mod-php5 后 /etc/apache2 又成为主配置目录，有点乱。不如直接用 php:5.5-apache 解决问题。</p>

<p>2016-04-12 02:34 Tuesday 刚看完《移动迷宫》，正下载《移动迷宫2》，外面开始下小雨</p>

<p>php-apache 默认 enable 了 mysqlnd，但并没有开启 --with-mysql=mysqlnd 选项，因此无法使用 mysql_connect 函数来连接数据库。正确的解决办法是：</p>

<pre>
​$ cat containers/php55-apache-mysql/Dockerfile&nbsp;
FROM php:5.5-apache

RUN docker-php-ext-configure mysql --with-mysql=mysqlnd &amp;&amp; \
&nbsp; &nbsp; docker-php-ext-install mysql</pre>

<p>其实此问题4天前在 smshosting 项目中已经解决了，今天白花了一天又走了一遍老路</p>

<pre>
$ gi l Dockerfile
* 2334dfc - Ma Lian -- 2016-04-07 15:15 Feature: docker build -t sms . (4 days ago)
</pre>

<h2>mysql</h2>

<p>2016-04-07 08:47&nbsp;Thursday 昨天收拾好了工作室的彩钢屋</p>

<p>https://hub.docker.com/_/mysql/</p>

<pre>
$ docker pull mysql:5.5
</pre>

<p>不加 -d 时，前台运行，但不响应&nbsp;Ctrl+C，所以还是加 -d 方便，但前台运行方便观察错误信息。--name 给它起个好记的名字，方便随后引用。-p 把 container 的 3306 映射到 &nbsp;docker-machine 的 3306，这样方便其它 container 连接。-v 把 docker-machine 上映射好的 /mysqldata&nbsp;挂载到 container 默认的 mysql 的&nbsp;data_dir（/var/lib/mysql）。/mysqldata 一定需要可写，通过 mount 时设定 uid=999 来实现，999 是&nbsp;container 中 mysql 用户的 id，可登录 container 查看 /etc/passwd 得到。此处单独给 mysql 映射并挂载是因为 /WORK 目录为了可写已经挂载为 docker(uid=1000) 用户，/WORK/databases/mysqldata 受此影响也属于&nbsp;docker 用户。</p>

<pre>
$ docker run -d --name mysql55 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=aaaa -v /mysqldata:/var/lib/mysql:rw mysql:5.5</pre>

<p>测试方式一，其中 mysql55 是上句中给生成的 container 的命名</p>

<pre>
$ docker exec -it mysql55 bash&nbsp;</pre>

<p>测试方式二，其中&nbsp;mysql55 是之前生成的 container 的名字，-h 的地址是 &nbsp;container 的真正地址，而不是 docker-machine 的地址，但如果 -p 映射过的话，就可以用 docker-machine 的地址了。</p>

<pre>
$ docker run -it --link mysql55:mysql --rm mysql:5.5 sh -c &#39;exec mysql -h&quot;172.17.0.3&quot; -P&quot;3306&quot; -uroot -p&quot;aaaa&quot;&#39;
</pre>

<h2>postgres</h2>

<p>2016-04-08 09:42 Friday</p>

<p>https://hub.docker.com/_/postgres/</p>

<p>本机目前 postgresql 版本是 9.4.5，故下载 postgres:9.4</p>

<pre>
$ docker pull postgres:9.4
</pre>

<p>本 image 默认已经开启了 5432 端口，所以 Dockerfile 中就不用重复了</p>

<pre>
$ cat Dockerfile&nbsp;
FROM postgres:9.4

RUN localedef -i zh_CN -c -f UTF-8 -A /usr/share/locale/locale.alias zh_CN.UTF-8

ENV LANG zh_CN.utf8
</pre>

<pre>
$ docker build -t pg .</pre>

<p>同&nbsp;mysql，此处 /pgdata 也需要事先在 VirtualBox 中配置好，在 container 中 postgres 用户的 id 也是 999</p>

<pre>
$ docker run --name tp-pg -p 5432:5432 -v /pgdata:/var/lib/postgresql/data postgres-postgis</pre>

<p>另外需要注意的是默认 postgresql 只侦听&nbsp;localhost，所以外部表现就是 5432 端口无法连接，此时需要编辑数据库目录中的 postgresql.conf 文件，修改 listen_addresses 为 *</p>

<pre>
$ vi /WORK/databases/pgdata/postgresql.conf</pre>

<pre>
listen_addresses = &#39;*&#39; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# what IP address(es) to listen on;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # comma-separated list of addresses;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # defaults to &#39;localhost&#39;; use &#39;*&#39; for all
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # (change requires restart)
#port = 5432 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (change requires restart)
</pre>

<h2>postgis</h2>

<p>2016-04-09 18:16 Saturday</p>

<p>在 Dockerfile 中使用如下两个命令来安装&nbsp;postgis。apt-get update 是必要的，否则 apt-get 找不到 postgis 相关的包。当前 postgis 最新版本已经是 2.2，但 /WORK/databases/pgdata 中使用的还是 2.1，所以此处需要安装 postgresql-9.4-postgis-2.1。</p>

<pre>
​RUN apt-get update

RUN apt-get install -y postgresql-9.4-postgis-2.1</pre>

<h2>geoserver</h2>

<p>2016-04-08 13:22 Friday</p>

<p>https://hub.docker.com/_/java/</p>

<p>下载这个映像时需反复尝试，VPN 如果不行再尝试去掉 VPN，结果下载成了。</p>

<pre>
$ docker pull java:7-jre-alpine</pre>

<p>当前 Dockerfile 很简单，解压然后待运行</p>

<pre>
$ cat Dockerfile&nbsp;
FROM java:7-jre-alpine

ENV GEOSERVER_HOME /geoserver-2.8.3

ADD $GEOSERVER_HOME-bin.zip /geoserver.bin.zip

RUN unzip /geoserver.bin.zip &gt; /dev/null
</pre>

<p>geoserver 的 DATA_DIR&nbsp;不需要&nbsp; mysql 和 postgres 那样的专有用户，所以直接从 /WORK 下映射即可</p>

<pre>
$ docker run --name tp-geos -p 8080:8080 -v /WORK/databases/geodata:/geoserver-2.8.3/data_dir geos /geoserver-2.8.3/bin/startup.sh
</pre>

<p>最后需要注意的就是 geoserver 启动后，如果有数据存储用到 postgresql 数据库的话，修改相关 host 指向 &nbsp;docker-machine 的地址就行了。</p>

<h2>What is Docker Machine?</h2>

<blockquote>
<p>boot2docker -&gt; Docker Machine</p>

<p>https://github.com/boot2docker/boot2docker-cli -&gt; https://docs.docker.com/machine/</p>
</blockquote>

<p>Docker Machine is a tool that lets you install Docker Engine on virtual hosts, and manage the hosts with&nbsp;<code>docker-machine</code>&nbsp;commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like AWS or Digital Ocean.</p>

<p>Docker Machine 是一个工具，用来在虚拟机上安装并管理 Docker Engine。</p>

<p>Using&nbsp;<code>docker-machine</code>&nbsp;commands, you can start, inspect, stop, and restart a managed host, upgrade the Docker client and daemon, and configure a Docker client to talk to your host.</p>

<p>使用 docker-machine 命令行，你可以启动，监视，停止和重启一个被管理的主机。</p>

<p>Point the Machine CLI at a running, managed host, and you can run<code>docker</code>&nbsp;commands directly on that host. For example, run<code>docker-machine env default</code>&nbsp;to point to a host called&nbsp;<code>default</code>, follow on-screen instructions to complete&nbsp;<code>env</code>&nbsp;setup, and run&nbsp;<code>docker ps</code>,<code>docker run hello-world</code>, and so forth.</p>
